//! Functions to generate result from zkVM given ELF and input.

use std::io::Write;

use anyhow::{Context, Result};
use clap::Parser;
use ethers::abi::Token;
use risc0_zkvm::{
    Executor, ExecutorEnv, LocalProver,
};
use alloy_sol_types::{sol, SolType};
use alloy::{
    primitives::{keccak256, Address, Signature},
    signers::{local::LocalSigner, Signer},
};
use k256::ecdsa::SigningKey;
use risc0_binfmt::compute_image_id;

type K256LocalSigner = LocalSigner<SigningKey>;

#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
enum Command {
    /// Prove the RISC-V ELF binary.
    Prove {
        /// The guest binary path
        guest_binary_path: String,

        /// The hex encoded input to provide to the guest binary
        input: String,

        /// Job ID (generated by JobManager contract)
        job_id: u32,

        /// The maximum number of cycles to run the program for
        max_cycles: u64,
    },
}

/// Run the CLI.
#[tokio::main]
pub async fn main() -> Result<()> {
    match Command::parse() {
        Command::Prove {
            guest_binary_path,
            input,
            job_id,
            max_cycles
        } => prove_ffi(
            guest_binary_path,
            hex::decode(input.strip_prefix("0x").unwrap_or(&input))?,
            job_id,
            max_cycles,
        ).await?,
    };

    Ok(())
}

/// Prints on stdio the Ethereum ABI and hex encoded proof.
async fn prove_ffi(elf_path: String, input: Vec<u8>, job_id: u32, max_cycles: u64) -> Result<()> {
    let elf = std::fs::read(elf_path).unwrap();
    let image_id = compute_image_id(&elf)?;
    let image_id_bytes = image_id.as_bytes().try_into().expect("image id is 32 bytes");
    let journal = prove(&elf, &input, max_cycles)?;
    let result_with_metadata = abi_encode_result_with_metadata(job_id, input, max_cycles, image_id_bytes, journal);
    
    let zkvm_operator_signature = sign_message(&result_with_metadata).await;

    let calldata = vec![Token::Bytes(result_with_metadata), Token::Bytes(zkvm_operator_signature)];
    let output = hex::encode(ethers::abi::encode(&calldata));

    // Forge test FFI calls expect hex encoded bytes sent to stdout
    print!("{output}");
    std::io::stdout()
        .flush()
        .context("failed to flush stdout buffer")?;
    Ok(())
}

/// Generates journal for the given elf and input.
fn prove(elf: &[u8], input: &[u8], max_cycles: u64) -> Result<Vec<u8>> {
    let env = ExecutorEnv::builder()
    .session_limit(Some(max_cycles))
    .write_slice(input)
    .build()?;

    let prover = LocalProver::new("locals only");
    let prove_info = prover.execute(env, elf)?;

    Ok(prove_info.journal.bytes)
}

/// The payload that gets signed to signify that the zkvm executor has faithfully
/// executed the job. Also the result payload the job manager contract expects.
///
/// tuple(JobID,ProgramInputHash,MaxCycles,VerifyingKey,RawOutput)
pub type ResultWithMetadata = sol! {
    tuple(uint32,bytes32,uint64,bytes32,bytes)
};

/// Returns an ABI-encoded result with metadata. This ABI-encoded response will be
/// signed by the operator.
pub fn abi_encode_result_with_metadata(job_id: u32, program_input: Vec<u8>, max_cycles: u64, program_verifying_key: &[u8; 32], raw_output: Vec<u8>) -> Vec<u8> {
    let program_input_hash = keccak256(program_input);
    ResultWithMetadata::abi_encode_params(&(
        job_id,
        program_input_hash,
        max_cycles,
        program_verifying_key,
        raw_output,
    ))
}

async fn sign_message(msg: &[u8]) -> Vec<u8> {
    let secret = "0x0c7ec7aefb80022c0025be1e72dadb0679aa294cb1db453b2e7b5da8616b4e31";
    let hex = if secret[0..2] == *"0x" { &secret[2..] } else { &secret[..] };
    let decoded = hex::decode(hex).unwrap();
    let signer = K256LocalSigner::from_slice(&decoded).unwrap();
    let sig = signer.sign_message(msg).await.unwrap();

    // Get the R, S, V components
    let r: [u8; 32] = sig.clone().r().to_be_bytes();
    let s : [u8; 32]= sig.clone().s().to_be_bytes();
    let mut v = sig.recovery_id().to_byte();
    v += 27;

    // Concatenate R, S, and V to form a 65-byte signature
    let mut out = Vec::with_capacity(65);
    out.extend_from_slice(&r);
    out.extend_from_slice(&s);
    out.push(v);

    out
}
